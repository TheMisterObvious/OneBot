const Discord = require("discord.js")
const { MessageButton, MessageActionRow } = require("discord-buttons")

exports.run = async(client, message, args) => {

    /* Assignements for all the buttons */

    const playlistFirst = new MessageButton()
    .setStyle("grey")
    .setLabel("1Ô∏è‚É£")
    .setID("playlist_first")

    const playlistSecond = new MessageButton()
    .setStyle("grey")
    .setLabel("2Ô∏è‚É£")
    .setID("playlist_second")

    const playlistThird = new MessageButton()
    .setStyle("grey")
    .setLabel("3Ô∏è‚É£")
    .setID("playlist_third")

    const playlistFourth = new MessageButton()
    .setStyle("grey")
    .setLabel("4Ô∏è‚É£")
    .setID("playlist_fourth")

    const playlistMainPreviousPage = new MessageButton()
    .setStyle("blurple")
    .setLabel("‚¨ÖÔ∏è")
    .setID("playlist_mainprevious")

    const playlistMainNextPage = new MessageButton()
    .setStyle("blurple")
    .setLabel("‚û°Ô∏è")
    .setID("playlist_mainnext")

    const playlistCreate = new MessageButton()
    .setStyle("green")
    .setLabel("‚ûï")
    .setID("playlist_create")

    const playlistDelete = new MessageButton()
    .setStyle("red")
    .setLabel("‚ûñ")
    .setID("playlist_delete")

    const playlistPreviousPage = playlistMainPreviousPage.setID("playlist_previous")

    const playlistNextPage = playlistMainNextPage.setID("playlist_next")

    const playlistAddMusic = playlistCreate.setID("playlist_addmusic")

    const playlistRemoveMusic = playlistDelete.setID("playlist_removemusic")

    const playlistSearch = new MessageButton()
    .setStyle("grey")
    .setLabel("üîç")
    .setID("playlist_search")

    const playlistVisibility = new MessageButton()
    .setStyle("grey")
    .setID("playlist_visibility")

    const playlistCopy = new MessageButton()
    .setStyle("grey")
    .setLabel("üìÉ")
    .setID("playlist_copy")
    .setDisabled(true)

    const playlistNowCopy = playlistCopy.setID("playlist_nowcopy")

    const playlistBack = new MessageButton()
    .setStyle("blurple")
    .setLabel("üîô")
    .setID("playlist_back")

    const playlistNowDelete = new MessageButton()
    .setStyle("red")
    .setLabel("üö´")
    .setID("playlist_nowdelete")
    .setDisabled(true)

    const playlistSearchPreviousPage = playlistMainPreviousPage.setID("playlist_searchprevious")

    const playlistSearchNextPage = playlistMainNextPage.setID("playlist_searchnext")

    const playlistSearchFirst = playlistFirst.setID("playlist_searchfirst")

    const playlistSearchSecond = playlistSecond.setID("playlist_searchsecond")

    const playlistSearchThird = playlistThird.setID("playlist_searchthird")

    const playlistSearchFourth = playlistFourth.setID("playlist_searchfourth")

    const playlistSearchBack = playlistBack.setID("playlist_searchback")

    const playlistSearchUser = new MessageButton()
    .setStyle("blurple")
    .setLabel("üë§")
    .setID("playlist_searchuser")

    /* ActionRow from buttons */

    const mainMenuPlaylists = new MessageActionRow()
    .addComponent(playlistMainPreviousPage)
    .addComponent(playlistMainNextPage)
    .addComponent(playlistCreate)
    .addComponent(playlistDelete)
    .addComponent(playlistSearch)

    const managePlaylist1 = new MessageActionRow()
    .addComponent(playlistPreviousPage)
    .addComponent(playlistNextPage)
    .addComponent(playlistAddMusic)
    .addComponent(playlistRemoveMusic)

    const emojisVisibilityTab = {
        "private": "üîí",
        "unlisted": "üîó",
        "public": "üåç"
    }

    const author = message.author || message.clicker.member.user
    const whereSend = message.channel || message.message.channel

    const serverQueue = client.player.getQueue(message)

    const playlists = client.db.get(author.id, "Playlist")
    const playlistsNames = Object.keys(playlists) || undefined

    function Success(successMessage) {
        return whereSend.send(new Discord.MessageEmbed().setDescription(`‚úÖ ${successMessage}`))
    }

    function Error(errorMessage) {
        return whereSend(new Discord.MessageEmbed().setDescription(`‚ùå ${errorMessage}`))
    }
    
    async function askingArgs(askingTitle, askingDesc, askingImage, askingError) {         

        if (!askingError || (!askingTitle && !askingDesc)) return console.log("Il me faut au moins un titre ou une description et obligatoirement une erreur !")

        const askingEmbed = new Discord.MessageEmbed()
        if (askingTitle) askingEmbed.setTitle(askingTitle)
        if (askingDesc) askingEmbed.setDescription(askingDesc)
        if (askingImage) askingEmbed.setImage(askingImage)

        return new Promise(async (resolver) => {
            msgTab = []
            if (message.author) whereSend.send(askingEmbed)
            else {
                for (const msg of message.channel.messages.cache) if (msg[1].author === client.user) msgTab.push(msg[1])
                whereSend.messages.cache.get(msgTab.reverse()[0].id).edit(askingEmbed)
            }
            await whereSend.awaitMessages(response => response.author.id === author.id, {
                max: 1,
                time: 10000,
                errors: ["time"],
            }).then(async collected => {
                resolver(collected.first().content.split(" "))
            }).catch((error) => {
                console.log(error)
                Error(askingError)
            })
        })
        
    }

    switch(args[0]?.toLowerCase()) {

        case "display":

            const playlistsEmbed = new Discord.MessageEmbed()
            .setColor("0072FF")
            .setTitle("__Vos playlists:__")

            if (!args[1] || !isNaN(args[1])) {

                if (!playlists || !Object.keys(playlists)[0]) {
                    playlistsEmbed.setDescription("Vous n'avez aucune playlist !")
                    if (message.author) whereSend.send("", {embed: playlistsEmbed, components: [playlistCreate, playlistDelete]})
                    else message.message.edit("", {embed: playlistsEmbed, components: [playlistCreate, playlistDelete]})
                    break
                }

                const pageAsked = Math.floor(args[1])

                const playlistPerPage = 4
                const lastPage = Math.ceil(playlistsNames.length/playlistPerPage)

                if (!pageAsked || isNaN(pageAsked) || pageAsked <= 1 || pageAsked > lastPage) var page = 1
                else var page = pageAsked

                const pagePlaylistList = playlistsNames.slice((page-1)*playlistPerPage, (page-1)*playlistPerPage+playlistPerPage)
                for (const playlistName of pagePlaylistList) {
                    const musicsInPlaylist = Object.keys(client.db.get(author.id, `Playlist.${playlistName}`)).length
                    const visibility = emojisVisibilityTab[client.db.get("PlaylistsVisibility",`${author.id}-${playlistName}`)[0]]
                    playlistsEmbed.addField(`‚Ä¢ ${playlistName} - ${visibility}`, `${musicsInPlaylist} titres dans cette playlist`)
                }

                playlistsEmbed.setFooter(`Page ${page}/${lastPage} | nombre de playlists: ${playlistsNames.length}`, author.avatarURL())

                const playlistsDisplayedLength = pagePlaylistList.length

                if (playlistsDisplayedLength < 4)  playlistFourth.setDisabled(true)
                if (playlistsDisplayedLength < 3)  playlistThird.setDisabled(true)
                if (playlistsDisplayedLength < 2)  playlistSecond.setDisabled(true)

                const displayPlaylist = new MessageActionRow()
                .addComponent(playlistFirst)
                .addComponent(playlistSecond)
                .addComponent(playlistThird)
                .addComponent(playlistFourth)
                .addComponent(playlistCopy)

                if (message.author) whereSend.send("", {embed: playlistsEmbed, components: [mainMenuPlaylists, displayPlaylist]})
                else message.message.edit("", {embed: playlistsEmbed, components: [mainMenuPlaylists, displayPlaylist]})

            } else {

                const playlistToDisplay = playlistsNames.map(playlistName => { if (playlistName.toLowerCase() === args[1].toLowerCase()) return playlistName }).filter(Boolean)[0]

                if (!playlistToDisplay) return message.channel.send(`Vous n'avez pas de playlist nomm√© ${args[1]}`)

                const pageAsked = Math.floor(args[2])
                const playlistToDisplayDB = client.db.get(author.id, `Playlist.${playlistToDisplay}`)

                const musicPerPage = 8
                const lastPage = Math.ceil(Object.keys(playlistToDisplayDB).length/musicPerPage)

                if (!pageAsked || isNaN(pageAsked) || pageAsked <= 1 || pageAsked > lastPage) var page = 1
                else var page = pageAsked

                var embeddesc = ""
                const pageMusicList = Object.keys(playlistToDisplayDB).slice((page-1)*musicPerPage, (page-1)*musicPerPage+musicPerPage)
                for (const musicIndex of pageMusicList) {
                    const musicToDisplay = playlistToDisplayDB[musicIndex]
                    embeddesc += `[${Number(musicIndex) + 1}] ‚Ä¢ **[${musicToDisplay.title}](${musicToDisplay.url})**\n__Auteur:__ ${musicToDisplay.author} - __Dur√©e:__ ${musicToDisplay.duration}\n\n`
                }

                if (!pageMusicList[0]) embeddesc = "Vous n'avez aucune musique dans cette playlist playlist !"

                playlistsEmbed.setDescription(embeddesc)
                playlistsEmbed.setTitle(`Musiques de la playlist __${playlistToDisplay}__:`)
                playlistsEmbed.setFooter(`Page ${page}/${lastPage} | Dur√©e de la playlist: wip`, author.avatarURL())

                playlistVisibility.setLabel(emojisVisibilityTab[client.db.get("PlaylistsVisibility",`${author.id}-${playlistToDisplay}`)[0]])

                const managePlaylist2 = new MessageActionRow()
                .addComponent(playlistBack)
                .addComponent(playlistVisibility)
                .addComponent(playlistNowCopy)
                .addComponent(playlistNowDelete)

                if (message.author) whereSend.send("", {embed: playlistsEmbed, components: [managePlaylist1, managePlaylist2]})
                else message.message.edit("", {embed: playlistsEmbed, components: [managePlaylist1, managePlaylist2]})

            }

            break

        case "create":

            /* Assigned args[1] to playlistCreatedName or ask for this argument if its undefined */
            const playlistCreatedName = args[1] || await askingArgs("Quelle nom voulez vous donner √† votre playlist ?", "En un mot seulement (les caract√®res comme - _ / ? etc... sont autoris√©s.", undefined, "Votre playlist n'a pas pu √™tre cr√©√© !").then(asked => { playlistCreatedName = asked[0] })
            
            /* Checking if the playlist name to create already exist and return an error if this case */
            var playlistToCreate
            if (playlists) playlistToCreate = playlistsNames.map(playlistName => playlistName.toLowerCase() === playlistCreatedName?.toLowerCase()).filter(true)[0]

            if (!playlistToCreate) Error(`Vous avez d√©j√† une playlist nomm√© ${playlistCreatedName}`)
            
            /* Created the playlist in the user's database and set his visibility to private by default */
            client.db.set(author.id, {}, `Playlist.${playlistToCreate}`)
            client.db.set("PlaylistsVisibility", ["private", author.tag], `${author.id}-${playlistToCreate}`)
            
            /* Return a success message and bring back the user to the playlist display */
            Success(`Playlist cr√©√© sous le nom **${playlistToCreate}**`)
            this.run(client, message, ["display"])

            break

        case "delete": //Delete playlist

            var playlistDeletedName
            if (!args[1]) await askingArgs("Quelle playlist voulez vous supprimer ?", undefined, undefined, "Votre playlist n'a pas pu √™tre supprim√© !").then(asked => { playlistDeletedName = asked[0] })
            else playlistDeletedName = args[1]

            var playlistToDelete
            for (const playlistName of playlistsNames) {
                if (playlistName.toLowerCase() === playlistDeletedName?.toLowerCase()) playlistToDelete = playlistName
            }
            
            if (!playlistToDelete) return Success(`Vous n'avez pas de playlist nomm√© **${playlistDeletedName}**`)
            else {
                whereSend.send(new Discord.MessageEmbed().setDescription(`√ätes vous sure de vouloir supprimer la playlist **${playlistDeletedName}** ?`))
                await whereSend.awaitMessages(response => response.author.id === author.id, {
                    max: 1,
                    time: 10000,
                    errors: ['time'],
                })
                .then(collected => {
                    if (collected.first().content.toLowerCase() === "oui") {
                        client.db.delete(author.id, `Playlist.${playlistToDelete}`)
                        client.db.delete("PlaylistsVisibility", `${author.id}-${playlistToDelete}`)
                        Success(`La playlist **${playlistToDelete}** √† bien √©t√© supprimer`)
                        this.run(client, message, ["display"])
                    }
                    if (collected.first().content.toLowerCase() === "non") {
                        Error(`Votre playlist n'a pas √©t√© supprim√©`)
                    }
                }).catch(() => {
                    Error(`Votre playlist n'a pas √©t√© supprim√©`)
                })
            }

            break

        case "add-music":

            var playlistWhereAdd
            if (!args[1]) await askingArgs("Dans quelle playlist voulez vous ajouter une musique ?", undefined, undefined, "Vous ne m'avez pas donn√© de nom de playlist.").then(asked => { playlistWhereAdd = asked[0] })
            else var playlistWhereAdd = args[1]

            if (!playlistsNames.map(obj => obj.toLowerCase()).includes(playlistWhereAdd.toLowerCase())) return Error(`Vous n'avez pas de playlist nomm√© ${playlistWhereRemove}`)

            var musicToAdd
            if (!args[2]) await askingArgs(`Quelle musique voulez vous ajouter √† la playlist ${playlistWhereAdd} ?`, "Seul une recherche de musique, un lien, l'argument -nowPlaying ou l'argument -allQueue peut √™tre accept√©, les liens de playlist ne sont pas acceptable pour le moment...", undefined, "J'ai annul√© votre recherche.").then(asked => { musicToAdd = asked.join(" ") })
            else var musicToAdd = args.slice(2).join(" ")

            if (musicToAdd.toLowerCase() === "-nowplaying") {
                if (!serverQueue) return Error("Il n'y a pas de musique entrain d'√™tre jou√© actuellement")
                
                const nowPlaying = serverQueue.tracks[0]

                client.db.set(author.id, nowPlaying, `Playlist.${playlistWhereAdd}.${Object.keys(client.db.get(author.id, `Playlist.${playlistWhereAdd}`)).length}`)
                Success(`__${nowPlaying.title}__ a bien √©t√© ajout√© √† la playlist **${playlistWhereAdd}**`)
                this.run(client, message, ["display"])
            
            } else if (musicToAdd.toLowerCase() === "-allqueue") {

                if (!serverQueue) return Error("Il n'a pas de musique entrain d'√™tre jou√© actuellement")
                
                const serverQueueTracks = serverQueue.tracks
                for (const musicQueue of serverQueueTracks) {
                    client.db.set(author.id, musicQueue, `Playlist.${playlistWhereAdd}.${Object.keys(client.db.get(author.id, `Playlist.${playlistWhereAdd}`)).length}`)
                }
                Success(`${serverQueueTracks.length} titres ont bien √©t√© ajout√©s √† la playlist **${playlistWhereAdd}**`)
                this.run(client, message, ["display"])
            
            } else {
                client.playerUtil.ytSearch(musicToAdd, {limit: 4}).then(async result => {
                    if (!result[0]) return Error("D√©sol√© je n'ai pas trouv√© de musique correspondant √† votre recherche")
                    var confirmation
                    await askingArgs("Est-ce bien ce titre ?", `__Titre:__ ${result[0].title}\n__Auteur:__ ${result[0].author}`, result[0].thumbnail, "Ajout de musique annul√©.").then(asked => { confirmation = asked[0].toLowerCase() })
                    if (confirmation === "oui") {
                        client.db.set(author.id, result[0], `Playlist.${playlistWhereAdd}.${Object.keys(client.db.get(author.id, `Playlist.${playlistWhereAdd}`)).length}`)
                        Success(`__${result[0].title}__ a bien √©t√© ajout√© √† la playlist **${playlistWhereAdd}**`)
                        this.run(client, message, ["display"])
                    }
                    if (confirmation === "non") {
                        var confirmationMultiple
                        await askingArgs("Est-ce l'un de ces titres ? Si oui, lequel ?", `**Titre 1 (r√©pondez 1)**\n__Titre:__ ${result[1].title}\n__Auteur:__ ${result[1].author}\n\n**Titre 2 (r√©pondez 2)**\n__Titre:__ ${result[2].title}\n__Auteur:__ ${result[2].author}\n\n**Titre 3 (r√©pondez 3)**\n__Titre:__ ${result[3].title}\n__Auteur:__ ${result[3].author}`, undefined, "Ajout de musique annul√©.").then(asked => { confirmationMultiple = asked[0] })
                        if (confirmationMultiple.toLowerCase() === "non") return Error("D√©sol√© je n'ai pas pu vous aider üò¢, essayez de changer d'√©l√©ments de recherches...")
                        if (confirmationMultiple === "1" || "2" || "3") {
                            client.db.set(author.id, result[confirmationMultiple], `Playlist.${playlistWhereAdd}.${Object.keys(client.db.get(author.id, `Playlist.${playlistWhereAdd}`)).length}`)
                            Success(`__${result[confirmationMultiple].title}__ a bien √©t√© ajout√© √† la playlist **${playlistWhereAdd}**`)
                            this.run(client, message, ["display"])
                        }
                    }
                })
            }
            break

        case "remove-music":

            var playlistWhereRemove
            if (!args[1]) await askingArgs("Dans quelle playlist voulez vous ajouter une musique ?", undefined, undefined, "Vous ne m'avez pas donn√© de nom de playlist.").then(asked => { playlistWhereRemove = asked[0] })
            else playlistWhereRemove = args[1]

            if (!playlistsNames.map(obj => obj.toLowerCase()).includes(playlistWhereRemove.toLowerCase())) return Error(`Vous n'avez pas playlist nomm√© ${playlistWhereRemove}`)
            
            var musicToRemove
            if (!args[2]) await askingArgs("Quelle est l'id/nom de la musique que vousvoulez supprimer de votre playlist ?", undefined, undefined, "Supression de la musique annul√©.").then(asked => { musicToRemove = asked.join(" ") })
            else musicToRemove = args.slice(2).join(" ")

            const playlistToRemoveData = client.db.get(author.id, `Playlist.${playlistWhereRemove}`) 

            if (isNaN(musicToRemove)) {
                var musicDelete
                for (const music of Object.values(playlistToRemoveData)) {
                    if (music.title.toLowerCase().includes(musicToRemove.toLowerCase())) musicDelete = music
                }

                if (!musicDelete) return Error(`Vous n'avez pas de musique nomm√© ${musicToRemove} dans cette playlist.`)
                
                const index = Object.keys(playlistToRemoveData).find(key => client.db.get(author.id, `Playlist.${playlistWhereRemove}.${key}`) === musicDelete)

                var confirmationDelete
                await askingArgs(`Voulez vous vraiment supprimer __${musicDelete.title}__ de la playlist **${playlistWhereRemove}**`, undefined, undefined, "Supression de la musique annul√©.").then(asked => { confirmationDelete = asked[0].toLowerCase() })
                
                if (confirmationDelete === "non") return Error("Suppression annul√©...")
                if (confirmationDelete === "oui") {
                    client.db.delete(author.id, `Playlist.${playlistWhereRemove}.${index}`)
                    for (const musicIndex of Object.keys(playlistToRemoveData)) {
                        if (musicIndex > index) {
                            client.db.set(author.id, playlistToRemoveData[musicIndex], `Playlist.${playlistWhereRemove}.${Number(musicIndex) - 1}`)
                            client.db.delete(author.id, `Playlist.${playlistWhereRemove}.${musicIndex}`)
                        }
                    }                         
                    Success(`__${musicDelete.title}__ a bien √©t√© supprimer de la playlist **${playlistWhereRemove}**`)
                    this.run(client, message, ["display"])
                }
            } else {
                const indexToDelete = Number(args[1]) - 1
                if (!playlistToRemoveData[indexToDelete]) Error(`Vous n'avez pas de musique avec l'id ${musicToRemove} dans cette playlist`)
                else {
                    const music = playlistToRemoveData[indexToDelete]

                    var confirmationDelete
                    await askingArgs(`Voulez vous vraiment supprimer __${music.title}__ de la playlist **${playlistWhereRemove}**`, undefined, undefined, "Supression de la musique annul√©.").then(asked => { confirmationDelete = asked[0].toLowerCase() })
                
                    if (confirmationDelete === "non") Error("Suppression annul√©...")
                    if (confirmationDelete === "oui") {
                        client.db.delete(message.author.id, `Playlist.${playlistWhereRemove}.${indexToDelete}`)
                        for (const musicIndex in playlistToRemoveData) {
                            if (musicIndex > indexToDelete) {
                                client.db.set(message.author.id, playlistToRemoveData[musicIndex], `Playlist.${playlistWhereRemove}.${Number(musicIndex) - 1}`)
                                client.db.delete(message.author.id, `Playlist.${playlistWhereRemove}.${musicIndex}`)
                            }
                        }                         
                        Success(`__${music.title}__ a bien √©t√© supprimer de la playlist **${playlistWhereRemove}**`)
                        this.run(client, message, ["display"])
                    }
                }
            }
            break

        case "visibility":

            var playlistToEdit
            if (!args[1]) await askingArgs("De quelle playlist voulez vous changer la visibilit√© ?", undefined, undefined, "Vous ne m'avez pas donn√© de nom de playlist.").then(asked => { confirmation = asked[0] })
            else playlistToEdit = args[1]
            
            if (!playlistToEdit) return
            if (!playlistsNames.map(obj => obj.toLowerCase()).includes(playlistToEdit.toLowerCase())) return Error(`Vous n'avez pas playlist nomm√© ${playlistToEdit}`)
            
            if (!args[2] || args[2] !== "public" || "unlisted" || "private") {
                var playlistNewVisibility
                if (message.author) await askingArgs("Quelle visibilit√© voulez vous assigner √† cette playlist ?", "les seules r√©ponses possibles sont `public`, `unlisted` ou `private`.", undefined, "Vous ne m'avez pas donn√© de param√®tre de visibilit√©.").then(asked => { confirmation = asked[0] })
                else {
                    var playlistNowVisibility = client.db.get("PlaylistsVisibility", `${author.id}-${playlistToEdit}`)[0]
                    if (playlistNowVisibility === undefined) playlistNewVisibility = "private"
                    if (playlistNowVisibility === "public") playlistNewVisibility = "private"
                    if (playlistNowVisibility === "unlisted") playlistNewVisibility = "public"
                    if (playlistNowVisibility === "private") playlistNewVisibility = "unlisted"
                }

                client.db.set("PlaylistsVisibility", [playlistNewVisibility, author.tag], `${author.id}-${playlistToEdit}`)
                if (!message.author) {
                    playlistVisibility.setLabel(emojisVisibilityTab[playlistNewVisibility])
                    const managePlaylist2 = new MessageActionRow()
                    .addComponent(playlistBack)
                    .addComponent(playlistVisibility)
                    .addComponent(playlistNowCopy)
                    .addComponent(playlistNowDelete)
                    message.message.edit("", {embed: message.message.embeds[0], components: [managePlaylist1, managePlaylist2]})
                }
            } else {

                if (message.author) { 
                    client.db.set("PlaylistsVisibility", [playlistNewVisibility, author.tag], `${author.id}-${playlistToEdit}`)
                
                    Success(`La playlist ${playlistToEdit} √† bien √©t√© pass√© en ${playlistNewVisibility}`)
                }

            }

            break

        case "search":

            const playlistsPublic = new Discord.MessageEmbed()
            .setColor("0072FF")
            .setTitle(`__${emojisVisibilityTab["public"]} Playlists publiques:__`)

            if (!args[1] || (!isNaN(args[1]) && args[1].length < 18)) {

                searchTab = []
                for (const playlistId of Object.keys(client.db.get("PlaylistsVisibility"))) {
                    const value = client.db.get("PlaylistsVisibility", playlistId)
                    if (value[0] === "public") searchTab.push(playlistId)
                }

                const pageAsked = Math.floor(args[2])

                const searchPerPage = 6
                const lastPage = Math.ceil(searchTab.length/searchPerPage)

                if (!pageAsked || isNaN(pageAsked) || pageAsked <= 1 || pageAsked > lastPage) var page = 1
                else var page = pageAsked

                const searchPlaylist = searchTab.slice((page-1)*searchPerPage, (page-1)*searchPerPage+searchPerPage)
                for (const publicPlaylistId of searchPlaylist) {
                    const playlistOwnerId = publicPlaylistId.slice(0, 18)
                    const publicPlaylistName = publicPlaylistId.slice(19, publicPlaylistId.length)

                    const musicsInPlaylist = Object.keys(client.db.get(playlistOwnerId, `Playlist.${publicPlaylistName}`)).length
                    
                    playlistsPublic.addField(`‚Ä¢ ${publicPlaylistName} - üë§: ${client.db.get("PlaylistsVisibility", publicPlaylistId)[1]}`, `${musicsInPlaylist} titres dans cette playlist | id: ${publicPlaylistId}`)
                }

                if (searchTab.length === 0) playlistsPublic.setDescription("Il n'y a pas de playlist publique.")

                playlistsPublic.setFooter(`Page ${page}/${lastPage} | nombre de playlists publiques: ${searchTab.length}`, author.avatarURL())

                const playlistsSearchedLength = searchPlaylist.length

                if (playlistsSearchedLength < 4)  playlistSearchFourth.setDisabled(true)
                if (playlistsSearchedLength < 3)  playlistSearchThird.setDisabled(true)
                if (playlistsSearchedLength < 2)  playlistSearchSecond.setDisabled(true)

                const displaySearchedPlaylist1 = new MessageActionRow()
                .addComponent(playlistSearchPreviousPage)
                .addComponent(playlistSearchNextPage)
                .addComponent(playlistSearchBack)
                .addComponent(playlistSearchUser)

                const displaySearchedPlaylist2 = new MessageActionRow()
                .addComponent(playlistSearchFirst)
                .addComponent(playlistSearchSecond)
                .addComponent(playlistSearchThird)
                .addComponent(playlistSearchFourth)

                if (message.author) whereSend.send("", {embed: playlistsPublic, components: [displaySearchedPlaylist1, displaySearchedPlaylist2]})
                else message.message.edit("", {embed: playlistsPublic, components: [displaySearchedPlaylist1, displaySearchedPlaylist2]})
                
            }

            break

        case "copy":

            break

        default:

            this.run(client, message, ["display"])
            break

    }
}


exports.config = {
    description: "[Musique] - Tout un syst√®me de playlist directement sur discord, plus besoin d'aller chercher le lien de votre playlist youtube ou spotify ou encore de regarder quelle est le titre de la musique que vous √©couter et d'aller l'ajouter manuellement sur votre playlist √† vous.",
    template: "playlist [action] [param√®tres...] [...] [...]",
    permission: "@everyone",
    aliases: ["pl", "playlists"]
}